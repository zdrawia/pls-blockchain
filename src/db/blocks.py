from typing import List

import bitstring

from src.db.mt import MerkleTree
from src.db.node import Node

# Root of Trust - то, что подписывает PLS на каждом раунде
class Block:
    def __init__(self, _id, tree=None, tree_hash=None, n=None, m=None, flags=None, bitmap=None, data=None):
        self.id: int = _id
        self.tree: MerkleTree = tree

        # hash requires the server to renumber the users, building a new MT and computing
        # its root hash. The user will recompute T to validate any leaf hash
        # and its adjunct hashes sent to it by CAS.
        # Merkle Tree
        # хэш от пустышки = пустышка, хаш от конкатенации двух пустышек = пустышка, хаш от пустышки и не пустышки = хаш от непустышки
        self.tree_hash = tree_hash

        # Те, thing, которые послали свои контрибуции в блок, они все собираются в кучу эти контрибуции
        # создается битмапа, где эти контрибуции, у каждого thing есть свой id, в соответствии с айди,
        # они расставляются в битмапу, затем битмапа сжимается и превращается в сжатую битмапу
        # все айди затем перенумеровываются, финг который был пятым - станет нулевым, так как слева от него ноль единиц
        # этот станет первым, так как слева одна единица, был десятым станет первым, этот станет вторым, а был двенадцатым,
        # третьим и пятнадцатым. Дальше из них делается мерклевское дерево. Самое обычное меркле три (формула восемь)
        # все контрибуции - 0, 1, 2, 3, 4, 5 ложатся в кас. юзер ноль был юзером пять, значит юзер пять послал свою запись в кас, и кас ответил хашом от записи, и хаш висит в дереве в нуле. юзер 1 был 10, послал контрибуцию, кас ответил хашом и теперь весит в единице.
        # далее есть битмапа - ее надо сжать тансталом, есть число юзеров пять - оно входит в m то есть тут 5 юзеров, число n -число зарегистрированных юзеров например 1024,
        # фи - биты для управления декодером и шафл шифтером, и блок битмап который сжат декодером, на картинке было 24 бита, а станет сколько то меньше, 13 например
        # так как это вариабильная штука, кончать надо единичкой с нулем все вариабельные строчки и при чтении их откусывать
        # получается битовая строка какогото размера мы вставляем ее в плс протокол и вещаем из сиквенсера, то есть рут оф траст это S запись плс протокола
        # когда юзер получает эту запись, он на основании n, m, фи разжимает битмапу.
        # хочу юзер 4 из блока 269. кас вытаскивает 269 и выдает adjunct path, то есть четверку, и два синих. мы это принимаем
        # производим калькуляцию 4 с пятым, и потом красный с синим и получим корень. заматчилось значит кас не обманул. заключаем что есть меркль пруф того что запись легла в блок 269 и можем следующую запись посылать
        # начнем с того что я не юзер номер двадцать, на самом деле я юзер 25, прошел через шафл шифтер, а что ему нужно - номер блока. шафл шифтер делает всегда 200 итераций а декодер всегда применяется.
        # если я хочу 45 юзер, тогда шифтер скажет что нет, 20, и я прихожу в битмапу а она говорит что я четвертый. а вот четвертый это то что понимает кас
        # кас хранит нормальное плотное меркль три
        # Mk - сообщение, представляет что угодно из себя. Mk - данные.
        # можно предположить что S сообщение одно.

        # шафл шифтер что он делает - есть диапазон чисел от 0 до 1024, теперь в этом диапажзоне можно сделать перестановку,
        # то есть переставить местами, перестановок этих n! (н-факториал), большое колво, поэтому выбран класс перестановок shuffle shift
        # их тоже много, но меньше, выбираем одну из них, они все перенумированы, перенумированы они номером блока, то есть их всего 1024 ращных перестановки
        # берем одну из них и переставляем местами, после перестановки 45 стало 20, а их как было 1024 так и осталось 1024.

        self.n = n
        self.m = m
        self.flags = flags

        self.bitmap = bitmap
        self.redundancy = bitstring.BitArray(32)

        self.data: dict[str, str] = data
